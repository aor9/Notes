### 시그널
##### 2. 다음 중 특정 group에 속하는 process들에게 signal을 보내는 명령으로 맞는 것을 모두 고르시오.
(1) kill(0, SIGINT);
##### 4. 위 프로그램의 ①의 위치에 다음 코드를 추가한 경우, 프로그램의 출력 결과로 맞는 것을 고르시오.
(2) 100 101 2 2 10 10 10 2 2 2 2 102
두번째 SIGINT를 blocking함.
SIGINT 처리가 다 안끝났을 때 SIGNINT가 또 오면 처리를 하지 않음.
### 메모리 매핑
##### 1. “data1” 파일에는 문자 ‘1’이 512개가 쓰여 있다. 다음 프로그램의 출력 결과로 맞는 것을 고르시오.
(4) segmentation fault 발생
addr=mmap(NULL, 10, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 30);
마지막 인자는 0 또는 PAGE 크기의 배수여야함. -> mapping 오류 발생
##### 5. “data1” 파일이 존재하지 않아 새로 만들어서 open 해야 하는 경우, 다음 프로그램의 출력 결과로 맞는 것을 고르시오.
(1) 0
공간 삭제 -> 삭제된 공간의 값 0으로 바뀜 (없는 공간이나 마찬가지), 삭제된 공간의 데이터 0을 출력한다.
### 파이프
##### 1. 다음 프로그램의 ①번 코드 없이 select문에서 &master를 직접 사용할 경우 발생하는 문제점으로 맞는 것을 모두 고르시오.
(2) 원하는 child의 입력 확인을 하지 못하는 경우가 발생한다.
(3) select 문에서 영구 block이 될 수도 있다. -> 검사할게 없어져서 blocking이 된다.
##### 3. 위 프로그램의 ③번 문장을 사용하지 않고 바로 read를 하는 경우 발생하는 문제점으로 맞는 것을 고르시오
(2) 메시지가 도착하지 않은 child에 대한 read 작업 시 block이 된다.
##### 4. 위 프로그램의 ④번 문장은 child process가 모두 종료 했는지 확인하는 문장이다. 이 문장을 사용하지 않고, child의 종료를 확인 할 수 있는 방법으로 맞는 것을 고르시오.
(4) read의 return 값을 확인한다. -> read의 return이 0이면 상대가 종료한것.
##### 6. 위 프로그램의 ③번 문장의 조건이 만족되어 출력이 진행되는 상황으로 맞는 것을 고르시오.
(3) A 프로그램이 종료하여, 해당 pipe를 O_RDWR 또는 O_WRONLY로 open 한 다른 프로그램이 전혀 없는 경우
##### 7. 
RDONLY로 열면 데이터가 쓰여질때까지 블록된 채로 대기
RDWR로 열면 읽기 쓰기 둘 다 가능해서 read 0이 반환되거나 블록되지 않는다.
### IPCS
10-1
##### 2. ②번 mtype에 대한 설명으로 맞지 않는 것을 고르시오.
(3) mtype에는 0 또는 양의 정수를 써야한다. -> 0 보다 큰 양의 정수를 써야함.
##### 6. ②번 코드의 semaphore 초기값 설정에 관한 설명으로 맞는 것을 고르시오.
(2) semaphore의 값은 0 또는 양수이다.
##### 7. ③번 코드에 대한 설명으로 맞는 것을 고르시오.
(3) semaphore의 값이 0이 될 때까지 대기하는 연산이다. -> semWait 연산이다.


10-2

##### 2. 위의 A 프로그램과 B 프로그램을 동시에 실행 시키고, A 프로그램에 1, 2, 3, 4, 5를 입력한 경우, ①번 출력문의 출력 결과로 맞는 것을 고르시오.
(2) 0, 0, 0, 0, 0 -> 동기화 하는 tool이 없어서 0으로 초기화 되어있다.
##### 3. 다음은 “data1” 파일에 저장된 10개의 정수를 읽어 +10을 한 후, 다시 파일에 쓰는 작업을 하는 프로그램이다. 이때, 파일의 읽기와 쓰기 작업 전에 해당 정수가 쓰여 진 위치에 lock을 걸고, 작업 후 lock을 해제하는 작업을 한다. ①번 코드의 F_SETLKW 대신 F_SETLK를 사용하는 경우에 대한 다음 설명으로 맞는 것을 고르시오.
- (3) F_SETLK를 사용하면, 해당 정수에 lock이 걸려있지 않은 경우에는 locking을 하지만, 해당 정수에 lock이 걸려 있는 경우에는 locking을 위한 대기를 하지 않는다.
##### 5. 한 프로세스가 위 프로그램을 실행시키고 있는 중에 다른 프로세스가 locking 없이 동일한 파일의 정수를 읽고, 변경하려고 한다. 다음 설명 중 맞는 것을 고르시오.
(4) locking 된 정수에 대한 읽기, 쓰기 모두 가능하다. -> locking 과 locking이 부딪히는 것만 검사한다. 그냥 읽기 쓰기는 가능. 