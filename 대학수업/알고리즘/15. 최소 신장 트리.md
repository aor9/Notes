신장 트리는 그래프의 모든 노드를 방문하고, 사이클이 없는 그래프이다.  
최소 신장 트리는 어떤 가중 그래프에서 가중치의 합이 최소가 되는 신장 트리이다.
최소 신장 트리는 두 가지 속성을 갖는다.
#### 사이클 속성
- T를 가중그래프 G의 최소신장트리라 하자.
- e를 T에 존재하지않는 G의 간선으로, C는 e를 T에 추가하여 형성된 사이클로 가정할 때, 
- **C의 모든 간선 f에 대해 weight(f) ≤ weight(e)가 성립한다**.

- 그래프 내에서 어떤 사이클에 속하는 두 정점을 연결하는 간선들 중에서 가중치가 가장 큰 간선은 최소 신장 트리에 포함되지 않는다는 속성입니다.
#### 분할 속성
- G의 노드들을 두 개의 부분집합 U, V로 분할
- e를 분할을 가로지르는 최소 무게의 간선이라 하면
- 간선 e를 포함하는 G의 최소신장 트리가 반드시 존재한다.
#### 탐욕법
- 탐욕적 선택 속성을 가진 문제에 적용할 경우 가장 잘 맞는다. 탐욕적 선택 속성이란, 매 순간 최선의 선택을 통해 전체 최적해를 항상 찾을 수 있는 속성이다.
	- 구성: 다양한 선택, 모음, 또는 찾아야 할 값들
	- 목표: 구성에 하당된 정수가 존재하며, 이를 최대화 또는 최소화해야 하는 상황
### 프림(Prim-Jarnik) 알고리즘
- 탐욕 알고리즘
- 임의의 정점 s를 선택하여, s로부터 시작하여 정점들을 배낭에 넣어가며 배낭안에서 MST T를 키워나간다. s는 T의 루트가 된다.
- 각 정점v에 라벨 d(v)를 정의하는데, 이는 배낭 내부의 정점과 외부의 정점을 연결하는 간선의 가중치이다.
	1. 반복의 각 회전에서 배낭 밖의 정점들 가운데 최소 d(z) 
	2.  z에 인접한 정점들의 라벨을 갱신한다.
- 각 정점은 우선순위 큐에 한번 삽입되고 한번 삭제되므로, O(logn) 시간이 소요되고, 각 노드의 키는 최대 deg(w) 번 변경되는데, 이는 가각 O(logn)시간 소요된다.
- 즉 그래프가 인접리스트 구조일 때, 알고리즘은 O((n + m) logn) 시간에 수행된다.
```c
Alg PrimJarnikMST(G)
	for v in G.vertices
		d(v) = infinite
		p(v) = null
	s = a vertex of G
	d(s) = 0
	Q = priority queue
	while !Q.isEmpty()
		u = Q.removeMin()
		for e in G.incidentEdges(u)
			z = G.opposite(u, e)
			if z in Q and w(u, z) < d(z)
				d(z) = w(u, z)
				p(z) = e
				Q.replaceKey(z, w(u, z))
```
### Kruskal 알고리즘
- 비용에 따라 오름차순으로 정렬하고 정렬한 순서대로 간선을 확인하면서 사이클을 만들지 않으면 포함하는 방식
- 시작할 때, 모든 노드를 각각의 독자적인 배낭에 넣는다. 배낭 밖의 간선들을 우선순위 큐에 넣는다. ( 키는 가중치 )
- 두 개의 다른 배낭 속에 양 끝점을 가진 최소 가중치 간선을 T에 포함하고, 두 배낭을 합친다. 반복을 마치면 MST가 담긴 배낭 하나만 남는다.
- 우선순위 큐 초기화에 상향식 힙 생성을 통해서는 O(m), 일반적인 방식으로는 O(mlogm)시간이 소요되고, 반복의 각 회전에서 최소 무게 간선을 O(logm)시간에 삭제 가능한데, 각 배낭을 위한 분리집합을 리스트로 구현하면 각 배낭을 연결하는 검사에 O(1) 시간이 걸린다.
- 크루스칼 알고리즘은 O((n + m)logn) 시간에 수행된다.
```c
dd
```
### Boruvka, Sollin 알고리즘
- 우선순위큐를 사용하지 않음, Kruskal 처럼 모든 노드를 각각의 배낭에 넣고 시작.
- 기존의 알고리즘과 달리, 한 회전에 여러개의 간선을 취하여 여러개의 배낭을 동시에 키워나간다.
- 각 정점마다 그에 딸린 간선 중 가장 비용이 저렴한 것을 찾아서 뭐시기
```c
dd
```
### MST 알고리즘 비교
![[Pasted image 20231204113052.png]]