### 시퀀스 컨테이너
데이터가 선형적으로 저장되는 컨테이너
##### 1. 벡터 (Vector)
- 동적 배열 구조, 런타임에 크기 임의 변경 가능.
- 메모리에 데이터가 연속적으로 위치함.
- 벡터는 포인터 세 개로 구현되어 있음.
	- 할당된 배열의 시작 주소를 가리키는 포인터
	- 다음 데이터가 삽입될 위치를 가리키는 포인터
	- 할당된 배열의 끝 주소를 가리키는 포인터
- 벡터의 메모리 할당 방식은 size(실제 사용 메모리 크기) 와 capacity(여유분 포함 메모리 크기)로 이루어짐.
	- 데이터를 삽입할 때, 할당된 공간이 전부 차면 **배열을 통째로 복사**해 새로운 벡터에 할당하는 방식으로 메모리 크기를 늘림. 때문에 벡터의 메모리를 적게 할당하고 계속 데이터를 늘릴경우 **복사 비용이 지속적**으로 들어 비효율적이게 됨.  **size를 충분히 확보**한 상태에서 사용하자.
##### 2. 배열 (Array)
- 그냥 배열
- 임의 접근(Random Access) 가능
##### 3. 리스트 (List)
- 노드 기반 컨테이너
- 이중 연결 리스트 (Double Linked List)와 같은 형식으로 구현되어 있다.
- 임의 접근(Random Access) 불가능
- 중간 부붐에서의 데이터 삭제가 벡터보다 효율적이다.
### 연관 컨테이너
Key - Value 구조를 가지는 컨테이너, 특정 기준에 따라 원소를 자동 정렬.
##### 1. 맵 (Map)
- 각 노드가 key 와 value의 쌍으로 이루어진 트리
- 중복을 허용하지 않는다.
- map의 각 원소들은 pair 객체로 저장, first가 key, second가 value로 저장
- Red-Black Tree 로 구현되어 있다. (이진 탐색 트리)
- 자료를 저장할 때 자동으로 key 값을 기준으로 오름차순 정렬한다.
	- 내림차순 정렬하려면 `map<type1, type2, greater<type1>>` 과 같이 선언
	- 자동 정렬하기 때문에 원소의 삽입이나 삭제가 빈번할 경우 성능 저하
- key를 통해 value에 접근
```c++
map<int, string> m;

m[1] = "ABC";
cout >> m[1];

실행 결과 : ABC
```
##### 2. unordered_map
- map과 다르게 값이 정렬되지 않고 랜덤하게 저장
	- 정렬이 필요 없는 경우 성능 향상이 가능
- Hash Table로 구현되어 있음.
	- unordered_map은 탐색을 상수 시간 O(1)에 처리할 수 있다.
- 많은 자료를 저장하고, 검색 속도가 빨라야 하는 경우에 사용하면 좋음. (자료양이 적을 때는 메모리 낭비 발생)