### 시간 복잡도
#### 시간 복잡도란?
- 가장 널리 사용되는 알고리즘의 수행 시간 기준으로, 알고리즘이 실행되는 동안 수행하는 기본적인 연산의 수를 **입력의 크기**에 대한 함수로 표현한 것.
> 기본적인 연산 : 더 작게 쪼갤 수 없는 최소 크기의 연산
> ex) 두 부호 있는 32비트 정수의 사칙연산, 두 실수형 변수의 대소 비교 ..

- 시간복잡도가 높다 = 입력의 크기가 증가할 때 알고리즘의 수행 시간이 더 빠르게 증가한다.
- 시간복잡도가 낮다고 해서 언제나 더 빠르게 동작하는 것은 아님.
	- 시간 복잡도가 낮은 알고리즘은 입력의 크기가 커지면 효율적.
#### 점근적 시간 표기 : O 표기
O 표기법은 간단하게 말해 주어진 함수에서 가장 빨리 증가하는 항만을 남긴 채 나머지를 다 버리는 표기법.
![[KakaoTalk_20230923_095843628.jpg]]
- 3번째 문제는 N^M 과 NM^2 둘 다 적는다. (N, M 중 뭐가 더 큰지 알 수 없기 때문)
- 4번째 문제는 상수로 값이 항상 일정하므로 O(1) 이라고 적는다.
### 수행 시간 어림 짐작하기
사실 수행시간을 어림 짐작 하는 것은 코딩테스트나 대회가 아니라면 쓸일이 많이 없을지도?
#### 주먹구구 법칙
> 입력의 크기를 시간 복잡도에 대입해서 얻은 반복문 수행 횟수에 대해, 1초당 반복문 수행 횟수가 1억(10^8)을 넘어가면 시간 제한을 초과할 가능성이 있다.

#### 주먹구구 법칙은 주먹구구일 뿐이다
- 이 법칙은 수많은 가정 위에 지어진 사상누각이기 때문에, 절대로 맹신해서는 안된다.
##### 시간복잡도 외에 고려해야할 다른 요소들
- 시간복잡도가 프로그램의 실제 수행 속도를 반영하지 못하는 경우
	- O 표기법은 상수나 최고차항 이외의 항들을 모두 지운 적당한 예측 값일 뿐이다.
	- 실제 프로그램이 수행하는 반복문의 수는 계산보다 클 수도 작을 수도 있다.
- 반복문의 내부가 복잡한 경우
	- 반복문의 내부는 단순하면 단술할 수록 좋다.
	- 복잡하면 가정보다 시간이 오래걸릴 수 밖에 없음.
- 메모리 사용 패턴이 복잡한 경우
	- 현대의 CPU는 자료에 직접 접근하는 대신 **캐시**라는 작고 빠른 메모리로 옮겨온 뒤 처리한다.
	- 캐시에서 메모리를 가져올 때 사용하는 방식은 공간 지역성, 시간 지역성이라는 특징이 있다.
	- 공간 지역성 : 한 메모리에 있는 자료를 가져올 때 근처에 있는 놈들에도 접근할 가능성이 높으므로 같이 가져온다.
	- 시간 지역성 : 한 번 불러온 놈은 또 불러올 수 있으므로 캐시에 저장해놓는다.
	- 이 두 특징 때문에 메모리 사용 패턴이 복잡하면 프로그램 수행 속도에 영향을 주게된다.
- 언어와 컴파일러의 차이
	- 언어나 컴파일러에 따라 다름.
- 구형 컴퓨터를 사용하는 경우
	- 최근 출시된 CPU들이 기준이 되므로 구형 컴 쓰면 차이남.